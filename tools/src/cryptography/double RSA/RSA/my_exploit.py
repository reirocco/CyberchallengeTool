'''
NOT WORKLING
    RSA encryption of a key with m <= 2^26; we have

    n = 0xf18af5fccbe293ccb2562f26c3753f2853081a19b94e3360648a02bf5301906f5eac584ef2b28a65edcb389879451e7e1b33341676f2d9a2c87469a0a36d1ec03f047e011b49305fcdf8d19de846c03f23035c5707593f391d725e58b47454c6f5e9484572423a7970aaf26f94f0ef5b8656c8f6febf5d5613dd6dbd8f0fba7a2c9765baa09613bb68b5df87b746e8c960e393a5ec5ea962211a91e506477c761836e1d4844adeab0efdccd9e1ff66398779823ad23971408d216db931e4425a1b16c2a778e5c4c7bcfba0c76a5aeab130c713b68de95087fc1fe12acb3aca6d4c822be6d6d5cbcd45bb3af83223fa93043af40fa29859090a4bdb70c93ce829
    e = 0x10001

    Ciphertext is
    c = 0xa224e5b79c5988a5e7f3f60d5875d0e78186306525b68fa6e90e45496412218a7a1162f0b89ef8747da6a0ea8acb3574e6a9e507fad8f72fe77dc1c49eccbd0870cab2b97ff0439b17f456283fce94e86d79661d0ab75193768262a0ba158bd240eac0240e73a74fe2506d5117684dea7ac7b8b2d76af7ff93112751853a60f6e6ab301ffe55f372718a01c05d3dfe02614a16f1fc0345354d479c48f4b0e98ea1fc4c2e587fe2deaedaac2cc5ae43291595d20c019e3ecf0dc68e6130107660a5b9157aa9f1eab09c8af34928a49f468db4aa4d9390d6c9e42e301f18638a13b1d9d9fdeb0ae84bc84c0491105beea465a049af85d060fc4a8882941da82aca


    Can you find m?
'''

from factordb.factordb import FactorDB
from Crypto.Util.number import long_to_bytes
import math
from sympy import mod_inverse
from solution import binary_search

if __name__ == '__main__':
    n = 0xf18af5fccbe293ccb2562f26c3753f2853081a19b94e3360648a02bf5301906f5eac584ef2b28a65edcb389879451e7e1b33341676f2d9a2c87469a0a36d1ec03f047e011b49305fcdf8d19de846c03f23035c5707593f391d725e58b47454c6f5e9484572423a7970aaf26f94f0ef5b8656c8f6febf5d5613dd6dbd8f0fba7a2c9765baa09613bb68b5df87b746e8c960e393a5ec5ea962211a91e506477c761836e1d4844adeab0efdccd9e1ff66398779823ad23971408d216db931e4425a1b16c2a778e5c4c7bcfba0c76a5aeab130c713b68de95087fc1fe12acb3aca6d4c822be6d6d5cbcd45bb3af83223fa93043af40fa29859090a4bdb70c93ce829
    e = 0x10001
    c = 0xa224e5b79c5988a5e7f3f60d5875d0e78186306525b68fa6e90e45496412218a7a1162f0b89ef8747da6a0ea8acb3574e6a9e507fad8f72fe77dc1c49eccbd0870cab2b97ff0439b17f456283fce94e86d79661d0ab75193768262a0ba158bd240eac0240e73a74fe2506d5117684dea7ac7b8b2d76af7ff93112751853a60f6e6ab301ffe55f372718a01c05d3dfe02614a16f1fc0345354d479c48f4b0e98ea1fc4c2e587fe2deaedaac2cc5ae43291595d20c019e3ecf0dc68e6130107660a5b9157aa9f1eab09c8af34928a49f468db4aa4d9390d6c9e42e301f18638a13b1d9d9fdeb0ae84bc84c0491105beea465a049af85d060fc4a8882941da82aca

    n = int(str(n), 16)
    e = int(str(e), 16)
    c = int(str(c), 16)
    print("n = ", n)
    print("e = ", e)
    print("c = ", c)

    key_length = 2 ** 13

    left_list = []
    right_list = []
    res = []
    for y in range(1, key_length):
        tmp = pow(y, e, n)
        tmp2 = mod_inverse(tmp, n)
        val = (tmp2 * c) % n
        left_list.append(val)

    indici, lista_interi = binary_search.efficient_list_sorting(left_list)

    for x in range(1, key_length):
        pos = None
        aok = pow(x, e, n)
        res = binary_search.dicotomic_search(lista_interi, 0, len(lista_interi) - 1, aok)
        if res is not None:
            y = indici[res]
            print("We found valid x and y values")
            print("y = " + str(y + 1) + ", x = " + str(x))
            print("m = " + str(x * (1 + y)))
            print("-----------------------------------------")
